"""empty message

Revision ID: cb8762f3c271
Revises: 8d8c816257ce
Create Date: 2020-07-14 15:05:11.517817

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'cb8762f3c271'
down_revision = '8d8c816257ce'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account_data',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('interest', sa.FLOAT(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('last_interest_rate_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('last_transfer_committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_config_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_config_seqnum', sa.Integer(), nullable=False),
    sa.Column('status_flags', sa.Integer(), nullable=False),
    sa.Column('last_heartbeat_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('last_transfer_number >= 0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id')
    )
    op.create_table('account_display',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_name', sa.String(), nullable=True),
    sa.Column('amount_divisor', sa.FLOAT(), nullable=False),
    sa.Column('decimal_places', sa.Integer(), nullable=False),
    sa.Column('own_unit', sa.String(), nullable=True),
    sa.Column('own_unit_preference', sa.Integer(), nullable=False),
    sa.Column('hide', sa.BOOLEAN(), nullable=False),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('peg_debtor_uri', sa.String(), nullable=True),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('latest_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('amount_divisor > 0.0'),
    sa.CheckConstraint('decimal_places >= -20 AND decimal_places <= 20'),
    sa.CheckConstraint('latest_update_id > 0'),
    sa.CheckConstraint('peg_exchange_rate >= 0.0'),
    sa.CheckConstraint('peg_exchange_rate IS NOT NULL OR peg_debtor_id IS NULL'),
    sa.CheckConstraint('peg_exchange_rate IS NULL OR peg_debtor_uri IS NOT NULL'),
    sa.ForeignKeyConstraint(['creditor_id', 'peg_debtor_id'], ['account_display.creditor_id', 'account_display.debtor_id'], ),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id')
    )
    op.create_index('idx_debtor_name', 'account_display', ['creditor_id', 'debtor_name'], unique=True, postgresql_where=sa.text('debtor_name IS NOT NULL'))
    op.create_index('idx_own_unit', 'account_display', ['creditor_id', 'own_unit'], unique=True, postgresql_where=sa.text('own_unit IS NOT NULL'))
    op.create_index('idx_peg_debtor_id', 'account_display', ['creditor_id', 'peg_debtor_id'], unique=False, postgresql_where=sa.text('peg_debtor_id IS NOT NULL'))
    op.create_table('account_exchange',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('policy', sa.String(), nullable=True),
    sa.Column('min_principal', sa.BigInteger(), nullable=False),
    sa.Column('max_principal', sa.BigInteger(), nullable=False),
    sa.Column('latest_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('latest_update_id > 0'),
    sa.CheckConstraint('min_principal <= max_principal'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id')
    )
    op.create_table('account_knowledge',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('interest_rate_changed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('identity_uri', sa.String(), nullable=True),
    sa.Column('debtor_url', sa.String(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('peg_debtor_uri', sa.String(), nullable=True),
    sa.Column('latest_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('latest_update_id > 0'),
    sa.CheckConstraint('peg_exchange_rate >= 0.0'),
    sa.CheckConstraint('peg_exchange_rate IS NULL OR peg_debtor_uri IS NOT NULL'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id')
    )
    op.create_table('configure_account_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('seqnum', sa.Integer(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('is_scheduled_for_deletion', sa.BOOLEAN(), nullable=False),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'ts', 'seqnum')
    )
    op.create_table('creditor',
    sa.Column('creditor_id', sa.BigInteger(), autoincrement=False, nullable=False),
    sa.Column('status', sa.SmallInteger(), nullable=False, comment="Creditor's status bits: 1 - is active."),
    sa.Column('created_at_date', sa.DATE(), nullable=False, comment='The date on which the creditor was created.'),
    sa.Column('deactivated_at_date', sa.DATE(), nullable=True, comment='The date on which the creditor was deactivated. A `null` means that the creditor has not been deactivated yet. Management operations (like making direct transfers) are not allowed on deactivated creditors. Once deactivated, a creditor stays deactivated until it is deleted. Important note: All creditors are created with their "is active" status bit set to `0`, and it gets set to `1` only after the first management operation has been performed.'),
    sa.Column('latest_log_entry_id', sa.BigInteger(), nullable=False),
    sa.Column('direct_transfers_count', sa.Integer(), nullable=False),
    sa.Column('accounts_count', sa.Integer(), nullable=False),
    sa.CheckConstraint('accounts_count >= 0'),
    sa.CheckConstraint('direct_transfers_count >= 0'),
    sa.CheckConstraint('latest_log_entry_id >= 0'),
    sa.PrimaryKeyConstraint('creditor_id'),
    comment="Represents creditor's principal information."
    )
    op.create_table('running_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_uuid', postgresql.UUID(as_uuid=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False, comment='The debtor through which the transfer should go.'),
    sa.Column('recipient', sa.String(), nullable=False, comment='The recipient of the transfer.'),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='The amount to be transferred. Must be positive.'),
    sa.Column('transfer_note', postgresql.JSON(astext_type=sa.Text()), nullable=False, comment='A note from the debtor. Can be any JSON object that the debtor wants the recipient to see.'),
    sa.Column('started_at_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the transfer was started.'),
    sa.Column('direct_coordinator_request_id', sa.BigInteger(), server_default=sa.text("nextval('direct_coordinator_request_id_seq')"), nullable=False, comment='This is the value of the `coordinator_request_id` parameter, which has been sent with the `prepare_transfer` message for the transfer. The value of `creditor_id` is sent as the `coordinator_id` parameter. `coordinator_type` is "direct".'),
    sa.Column('direct_transfer_id', sa.BigInteger(), nullable=True, comment='This value, along with `debtor_id` and `creditor_id` uniquely identifies the successfully prepared transfer.'),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('creditor_id', 'transfer_uuid'),
    comment='Represents a running direct transfer. Important note: The records for the successfully finalized direct transfers (those for which `direct_transfer_id` is not `null`), must not be deleted right away. Instead, after they have been finalized, they should stay in the database for at least few days. This is necessary in order to prevent problems caused by message re-delivery.'
    )
    op.create_index('idx_direct_coordinator_request_id', 'running_transfer', ['creditor_id', 'direct_coordinator_request_id'], unique=True)
    op.create_table('account_ledger',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False, comment='The date on which the account was created. This is needed to detect when an account has been deleted, and recreated again. (In that case the sequence of `transfer_number`s will be broken, the old ledger should be discarded, and a brand new ledger created).'),
    sa.Column('principal', sa.BigInteger(), nullable=False, comment='The account principal, as it is after the last transfer has been added to the ledger.'),
    sa.Column('next_transfer_number', sa.BigInteger(), nullable=False, comment="The anticipated `transfer_number` for the next transfer. It gets incremented when a new transfer is added to the ledger. For a newly created (or purged, and then recreated) account, the sequential number of the first transfer will have its lower 40 bits set to `0x0000000001`, and its higher 24 bits calculated from the account's creation date (the number of days since Jan 1st, 1970). Note that when an account has been removed from the database, and then recreated again, for this account, a gap will occur in the generated sequence of `transfer_number`s."),
    sa.Column('last_update_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the most recent change in the row happened.'),
    sa.CheckConstraint('next_transfer_number > 0'),
    sa.CheckConstraint('principal > -9223372036854775808'),
    sa.ForeignKeyConstraint(['creditor_id'], ['creditor.creditor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Represents essential information about the ledger of a given account. Logically those columns belong to the `account_config` table, but they are isolated here mainly for peformace reasons. The thing is that we want really fast index-only scans on the `account_config` table. Normally, the account config rarely changes (which is good for the index-only scans), while the account ledger information may change very frequently.'
    )
    op.create_index('idx_next_transfer_number', 'account_ledger', ['creditor_id', 'debtor_id', 'next_transfer_number'], unique=False)
    op.create_table('direct_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_uuid', postgresql.UUID(as_uuid=True), nullable=False),
    sa.Column('debtor_uri', sa.String(), nullable=False, comment="The debtor's URI."),
    sa.Column('recipient_uri', sa.String(), nullable=False, comment="The recipient's URI."),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='The amount to be transferred. Must be positive.'),
    sa.Column('transfer_note', postgresql.JSON(astext_type=sa.Text()), nullable=False, comment='A note from the sender. Can be any JSON object that the sender wants the recipient to see.'),
    sa.Column('initiated_at_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the transfer was initiated.'),
    sa.Column('finalized_at_ts', sa.TIMESTAMP(timezone=True), nullable=True, comment='The moment at which the transfer was finalized. A `null` means that the transfer has not been finalized yet.'),
    sa.Column('is_successful', sa.BOOLEAN(), nullable=False, comment='Whether the transfer has been successful or not.'),
    sa.Column('json_error', postgresql.JSON(astext_type=sa.Text()), nullable=True, comment='Describes the reason of the failure, in case the transfer has not been successful.'),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('finalized_at_ts IS NULL OR is_successful = true OR json_error IS NOT NULL'),
    sa.CheckConstraint('is_successful = false OR finalized_at_ts IS NOT NULL'),
    sa.ForeignKeyConstraint(['creditor_id'], ['creditor.creditor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'transfer_uuid'),
    comment='Represents an initiated direct transfer. A new row is inserted when a creditor creates a new direct transfer. The row is deleted when the creditor acknowledges (purges) the transfer.'
    )
    op.create_table('account_commit',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('transfer_note', sa.TEXT(), nullable=False),
    sa.Column('transfer_flags', sa.Integer(), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.Column('sender', sa.String(), nullable=False),
    sa.Column('recipient', sa.String(), nullable=False),
    sa.CheckConstraint('account_new_principal > -9223372036854775808'),
    sa.CheckConstraint('committed_amount != 0'),
    sa.CheckConstraint('transfer_number > 0'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_ledger.creditor_id', 'account_ledger.debtor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'transfer_number'),
    comment='Represents an account commit. A new row is inserted when a `AccountCommitSignal` is received. The row is deleted when some time (few months for example) has passed.'
    )
    op.create_table('account_config',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('created_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('has_account', sa.BOOLEAN(), nullable=False, comment='Whether a corresponding `account` record exists.'),
    sa.Column('is_effectual', sa.BOOLEAN(), nullable=False, comment='Whether the last change in the configuration has been successfully applied.'),
    sa.Column('last_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The timestamp of the last sent `configure_account` signal. Must never decrease.'),
    sa.Column('last_seqnum', sa.Integer(), nullable=False, comment='The sequential number of the last sent `configure_account` signal. It is incremented (with wrapping) on every change. This column, along with the `last_ts` column, allows to reliably determine the correct order of changes, even if they occur in a very short period of time.'),
    sa.Column('is_scheduled_for_deletion', sa.BOOLEAN(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('account_identity', sa.String(), nullable=True, comment='The value of the `account_identity` field from the first received `AccountChangeSignal` for the account.'),
    sa.Column('allow_unsafe_removal', sa.BOOLEAN(), nullable=False, comment='Whether the owner approved unsafe removal of the account. In extraordinary circumstances it might be necessary to forcefully remove an account, accepting the risk of losing the available amount.'),
    sa.CheckConstraint('negligible_amount >= 0.0'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_ledger.creditor_id', 'account_ledger.debtor_id'], ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment="Represents a configured (created) account from users' perspective. Note that a freshly inserted `account_config` record will not have a corresponding `account` record."
    )
    op.create_table('account',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('interest', sa.FLOAT(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('config_flags', sa.Integer(), nullable=False),
    sa.Column('status_flags', sa.Integer(), nullable=False),
    sa.Column('last_heartbeat_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the last `AccountChangeSignal` has been processed. It is used to detect "dead" accounts. A "dead" account is an account that have been removed from the `swpt_accounts` service, but still exist in this table.'),
    sa.CheckConstraint('interest_rate >= -50.0 AND interest_rate <= 100.0'),
    sa.CheckConstraint('last_transfer_number >= 0'),
    sa.CheckConstraint('negligible_amount >= 0.0'),
    sa.CheckConstraint('principal > -9223372036854775808'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_config.creditor_id', 'account_config.debtor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Tells who owes what to whom. This table is a replica of the table with the same name in the `swpt_accounts` service. It is used to perform maintenance routines like changing interest rates. Most of the columns get their values from the corresponding fields in the last applied `AccountChangeSignal`.'
    )
    op.create_table('ledger_entry',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.Column('added_at_ts', sa.TIMESTAMP(timezone=True), server_default=sa.text("TIMEZONE('utc', CURRENT_TIMESTAMP)"), nullable=False),
    sa.CheckConstraint('account_new_principal > -9223372036854775808'),
    sa.CheckConstraint('committed_amount != 0'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id', 'transfer_number'], ['account_commit.creditor_id', 'account_commit.debtor_id', 'account_commit.transfer_number'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_ledger.creditor_id', 'account_ledger.debtor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'transfer_number'),
    comment="Represents an entry in one of creditor's account ledgers. This table allows users to ask only for transfers that have occurred before or after a given moment in time."
    )
    op.create_index('idx_ledger_entry_added_at_ts', 'ledger_entry', ['creditor_id', 'added_at_ts', 'debtor_id', 'transfer_number', 'committed_amount', 'account_new_principal'], unique=False)
    op.create_table('pending_account_commit',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('committed_amount != 0'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id', 'transfer_number'], ['account_commit.creditor_id', 'account_commit.debtor_id', 'account_commit.transfer_number'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'transfer_number', 'committed_amount', 'account_new_principal'),
    comment='Represents an account commit that has not been included in the account ledger yet. A new row is inserted when a `AccountCommitSignal` is received. Periodically, the pending rows are processed, added to account ledgers, and then deleted. This intermediate storage is necessary, because account commits can be received out-of-order, but must be added to the ledgers in-order.'
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('pending_account_commit')
    op.drop_index('idx_ledger_entry_added_at_ts', table_name='ledger_entry')
    op.drop_table('ledger_entry')
    op.drop_table('account')
    op.drop_table('account_config')
    op.drop_table('account_commit')
    op.drop_table('direct_transfer')
    op.drop_index('idx_next_transfer_number', table_name='account_ledger')
    op.drop_table('account_ledger')
    op.drop_index('idx_direct_coordinator_request_id', table_name='running_transfer')
    op.drop_table('running_transfer')
    op.drop_table('creditor')
    op.drop_table('configure_account_signal')
    op.drop_table('account_knowledge')
    op.drop_table('account_exchange')
    op.drop_index('idx_peg_debtor_id', table_name='account_display')
    op.drop_index('idx_own_unit', table_name='account_display')
    op.drop_index('idx_debtor_name', table_name='account_display')
    op.drop_table('account_display')
    op.drop_table('account_data')
    # ### end Alembic commands ###
