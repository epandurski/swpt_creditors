"""empty message

Revision ID: d4d4f70320c6
Revises: 8d8c816257ce
Create Date: 2020-01-29 20:15:49.236815

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'd4d4f70320c6'
down_revision = '8d8c816257ce'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account_ledger',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('next_transfer_seqnum', sa.BigInteger(), nullable=False),
    sa.Column('last_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('next_transfer_seqnum > 0'),
    sa.CheckConstraint('principal > -9223372036854775808'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Contains status information about the ledger of a given account.'
    )
    op.create_index('idx_next_transfer_seqnum', 'account_ledger', ['creditor_id', 'debtor_id', 'next_transfer_seqnum'], unique=False)
    op.create_table('committed_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_seqnum', sa.BigInteger(), nullable=False, comment='Along with `creditor_id` and `debtor_id` uniquely identifies the committed transfer. It gets incremented on each committed transfer. Initially, `transfer_seqnum` has its lowest 40 bits set to zero, and its highest 24 bits calculated from the value of `account_creation_date`.'),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False, comment='Indicates which subsystem has committed the transfer.'),
    sa.Column('other_creditor_id', sa.BigInteger(), nullable=False, comment='The creditor ID of other party in the transfer. When `committed_amount` is positive, this is the sender. When `committed_amount` is negative, this is the recipient.'),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('transfer_info', postgresql.JSON(astext_type=sa.Text()), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False, comment='The date on which the account was created. This is needed to detect when an account has been deleted, and re-created again. (In that case the sequence of `transfer_seqnum`s will be broken, the old ledger should be discarded, and a brand new ledger created).'),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False, comment='The balance on the account after the transfer.'),
    sa.CheckConstraint('account_new_principal > -9223372036854775808'),
    sa.CheckConstraint('committed_amount != 0'),
    sa.CheckConstraint('transfer_seqnum > 0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'transfer_seqnum'),
    comment='Represents a committed transfer. A new row is inserted when a `CommittedTransferSignal` is received. The row is deleted when some time (few months for example) has passed.'
    )
    op.create_table('creditor',
    sa.Column('creditor_id', sa.BigInteger(), autoincrement=False, nullable=False),
    sa.Column('status', sa.SmallInteger(), nullable=False, comment="Creditor's status bits: 1 - is active."),
    sa.Column('created_at_date', sa.DATE(), nullable=False, comment='The date on which the creditor was created.'),
    sa.Column('deactivated_at_date', sa.DATE(), nullable=True, comment='The date on which the creditor was deactivated. A `null` means that the creditor has not been deactivated yet. Management operations (like making direct transfers) are not allowed on deactivated creditors. Once deactivated, a creditor stays deactivated until it is deleted. Important note: All creditors are created with their "is active" status bit set to `0`, and it gets set to `1` only after the first management operation has been performed.'),
    sa.PrimaryKeyConstraint('creditor_id')
    )
    op.create_table('ledger_addition',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('added_at_ts', sa.TIMESTAMP(timezone=True), server_default=sa.text("TIMEZONE('utc', CURRENT_TIMESTAMP)"), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_seqnum', sa.BigInteger(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('account_new_principal > -9223372036854775808'),
    sa.PrimaryKeyConstraint('creditor_id', 'added_at_ts', 'debtor_id', 'transfer_seqnum', 'account_new_principal'),
    comment="Represents an addition to creditors' account ledgers. This table is needed to allow users to store the sequential number of the last seen transfer (`addition_seqnum`), and later on, ask only for transfers with bigger sequential numbers."
    )
    op.create_table('running_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_uuid', postgresql.UUID(as_uuid=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False, comment='The debtor through which the transfer should go.'),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False, comment='The recipient of the transfer.'),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='The amount to be transferred. Must be positive.'),
    sa.Column('transfer_info', postgresql.JSON(astext_type=sa.Text()), nullable=True, comment='Notes from the sender. Can be any JSON object that the sender wants the recipient to see. Can be set `null` (to save disk space) only after the transfer has been finalized.'),
    sa.Column('finalized_at_ts', sa.TIMESTAMP(timezone=True), nullable=True, comment='The moment at which the transfer was finalized. A `null` means that the transfer has not been finalized yet.'),
    sa.Column('direct_coordinator_request_id', sa.BigInteger(), server_default=sa.text("nextval('direct_coordinator_request_id_seq')"), nullable=False, comment='This is the value of the `coordinator_request_id` parameter, which has been sent with the `prepare_transfer` message for the transfer. The value of `creditor_id` is sent as the `coordinator_id` parameter. `coordinator_type` is "direct".'),
    sa.Column('direct_transfer_id', sa.BigInteger(), nullable=True, comment='This value, along with `debtor_id` and `creditor_id` uniquely identifies the successfully prepared transfer.'),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('direct_transfer_id IS NULL OR finalized_at_ts IS NOT NULL'),
    sa.CheckConstraint('transfer_info IS NOT NULL OR finalized_at_ts IS NOT NULL'),
    sa.PrimaryKeyConstraint('creditor_id', 'transfer_uuid'),
    comment='Represents a running direct transfer. Important note: The records for the finalized direct transfers (failed or successful) must not be deleted right away. Instead, after they have been finalized, they should stay in the database for at least few days. This is necessary in order to prevent problems caused by message re-delivery.'
    )
    op.create_index('idx_direct_coordinator_request_id', 'running_transfer', ['debtor_id', 'direct_coordinator_request_id'], unique=True)
    op.create_table('account_config',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('created_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('is_effectual', sa.BOOLEAN(), nullable=False, comment='Whether the last change in the configuration has been successfully applied.'),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The timestamp of the last change in the configuration. Must never decrease.'),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False, comment='The sequential number of the last change in the configuration. It is incremented (with wrapping) on every change. This column, along with the `last_change_ts` column, allows to reliably determine the correct order of changes, even if they occur in a very short period of time.'),
    sa.Column('is_scheduled_for_deletion', sa.BOOLEAN(), nullable=False, comment='The maximum account balance that should be considered negligible. It is used to decide whether an account can be safely deleted.'),
    sa.Column('negligible_amount', sa.REAL(), nullable=False, comment='Whether the account is scheduled for deletion.'),
    sa.CheckConstraint('negligible_amount >= 2.0'),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_ledger.creditor_id', 'account_ledger.debtor_id'], ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment="Represents a configured (created) account from users' perspective. Note that a freshly inserted `account_config` record will have no corresponding `account` record. Also, an `account_config` record must not be deleted, unless its `is_effectual` column is `true` and there is no corresponding `account` record."
    )
    op.create_table('initiated_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_uuid', postgresql.UUID(as_uuid=True), nullable=False),
    sa.Column('debtor_uri', sa.String(), nullable=False, comment="The debtor's URI."),
    sa.Column('recipient_uri', sa.String(), nullable=False, comment="The recipient's URI."),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='The amount to be transferred. Must be positive.'),
    sa.Column('transfer_info', postgresql.JSON(astext_type=sa.Text()), nullable=False, comment='Notes from the sender. Can be any object that the sender wants the recipient to see.'),
    sa.Column('initiated_at_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the transfer was initiated.'),
    sa.Column('finalized_at_ts', sa.TIMESTAMP(timezone=True), nullable=True, comment='The moment at which the transfer was finalized. A `null` means that the transfer has not been finalized yet.'),
    sa.Column('is_successful', sa.BOOLEAN(), nullable=False, comment='Whether the transfer has been successful or not.'),
    sa.Column('error_code', sa.String(), nullable=True, comment='The error code, in case the transfer has not been successful.'),
    sa.Column('error_message', sa.String(), nullable=True, comment='The error message, in case the transfer has not been successful.'),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('error_code IS NULL OR error_message IS NOT NULL'),
    sa.CheckConstraint('finalized_at_ts IS NULL OR is_successful = true OR error_code IS NOT NULL'),
    sa.CheckConstraint('is_successful = false OR finalized_at_ts IS NOT NULL'),
    sa.ForeignKeyConstraint(['creditor_id'], ['creditor.creditor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'transfer_uuid'),
    comment='Represents an initiated direct transfer. A new row is inserted when a creditor creates a new direct transfer. The row is deleted when the creditor acknowledges (purges) the transfer.'
    )
    op.create_table('pending_committed_transfer',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_seqnum', sa.BigInteger(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id', 'transfer_seqnum'], ['committed_transfer.creditor_id', 'committed_transfer.debtor_id', 'committed_transfer.transfer_seqnum'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'transfer_seqnum', 'account_new_principal'),
    comment='Represents a committed transfer that has not been included in the account ledger yet. A new row is inserted when a `CommittedTransferSignal` is received. Periodically, the pending rows are processed, added to account ledgers, and then deleted. This intermediate storage is necessary, because committed transfers can be received out of order, but must be added to the ledgers in order.'
    )
    op.create_table('account_issue',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('issue_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('issue_type', sa.String(length=30), nullable=False),
    sa.Column('issue_can_be_deleted', sa.BOOLEAN(), nullable=False),
    sa.Column('raised_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('details', postgresql.JSON(astext_type=sa.Text()), nullable=False),
    sa.ForeignKeyConstraint(['creditor_id', 'debtor_id'], ['account_config.creditor_id', 'account_config.debtor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('creditor_id', 'issue_id'),
    comment='Represents a problem with a given account that needs attention.'
    )
    op.create_index('idx_account_issue_debtor_id', 'account_issue', ['creditor_id', 'debtor_id'], unique=False)
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('idx_account_issue_debtor_id', table_name='account_issue')
    op.drop_table('account_issue')
    op.drop_table('pending_committed_transfer')
    op.drop_table('initiated_transfer')
    op.drop_table('account_config')
    op.drop_index('idx_direct_coordinator_request_id', table_name='running_transfer')
    op.drop_table('running_transfer')
    op.drop_table('ledger_addition')
    op.drop_table('creditor')
    op.drop_table('committed_transfer')
    op.drop_index('idx_next_transfer_seqnum', table_name='account_ledger')
    op.drop_table('account_ledger')
    # ### end Alembic commands ###
